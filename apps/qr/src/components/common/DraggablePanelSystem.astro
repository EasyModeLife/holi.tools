---
/**
 * DraggablePanelSystem.astro - Panel positioning and drag system
 *
 * This component should be included once in a layout that uses DraggablePanel components.
 * It provides:
 * - Smart positioning to avoid overlaps
 * - Drag-and-drop functionality
 * - Position memory
 * - Global toggle/close functions
 *
 * Configuration:
 * - panelIds: Array of panel IDs to manage (default: ["color", "style", "logo", "advanced"])
 * - panelSides: Object mapping panel IDs to sides ("left" | "right")
 * - centerElementSelector: Selector for the center element to avoid (default: "#qr-frame")
 * - searchBarSelector: Selector for search bar to stay below (default: ".shared-input-container")
 */

interface Props {
  panelIds?: string[];
  panelSides?: Record<string, "left" | "right">;
  centerElementSelector?: string;
  searchBarSelector?: string;
}

const {
  panelIds = ["color", "style", "logo", "advanced"],
  panelSides = {
    color: "right",
    style: "right",
    logo: "left",
    advanced: "left",
  },
  centerElementSelector = "#qr-frame",
  searchBarSelector = ".shared-input-container",
} = Astro.props;

// Serialize for inline script
const panelIdsJson = JSON.stringify(panelIds);
const panelSidesJson = JSON.stringify(panelSides);
---

<script
  is:inline
  define:vars={{
    panelIdsJson,
    panelSidesJson,
    centerElementSelector,
    searchBarSelector,
  }}
>
  // Parse configuration
  const panelIds = JSON.parse(panelIdsJson);
  const panelSide = JSON.parse(panelSidesJson);

  // Panel state: remembers positions and handles collision detection
  const panelState = {};
  panelIds.forEach((id) => {
    panelState[id] = { x: null, y: null, hasUserPosition: false };
  });

  // Get all visible panels and their bounding boxes
  function getVisiblePanels() {
    const panels = [];
    panelIds.forEach((id) => {
      const panel = document.getElementById("panel-" + id);
      if (panel && panel.style.display !== "none") {
        panels.push({ id, rect: panel.getBoundingClientRect() });
      }
    });
    return panels;
  }

  // Check if two rectangles overlap
  function rectsOverlap(r1, r2, margin = 10) {
    return !(
      r1.right + margin < r2.left ||
      r1.left - margin > r2.right ||
      r1.bottom + margin < r2.top ||
      r1.top - margin > r2.bottom
    );
  }

  // Get smart position for a panel based on its side preference
  function getSmartPosition(panelId) {
    const viewWidth = window.innerWidth;
    const viewHeight = window.innerHeight;
    const centerEl = document.querySelector(centerElementSelector);
    const centerRect = centerEl
      ? centerEl.getBoundingClientRect()
      : { left: viewWidth / 2 - 140, right: viewWidth / 2 + 140 };
    const searchBar = document.querySelector(searchBarSelector);
    const minY = searchBar
      ? searchBar.getBoundingClientRect().bottom + 15
      : 140;

    const gap = 20;
    const panelWidth = 260;
    const side = panelSide[panelId] || "right";

    // Calculate X based on side
    const leftX = Math.max(10, centerRect.left - panelWidth - gap);
    const rightX = Math.min(
      centerRect.right + gap,
      viewWidth - panelWidth - 10
    );
    const x = side === "left" ? leftX : rightX;

    // Measure height of visible panels on same side
    let stackY = minY;
    const visiblePanels = getVisiblePanels();
    for (const vp of visiblePanels) {
      const vpSide = panelSide[vp.id] || "right";
      if (vpSide === side) {
        // Same side - stack below
        stackY = Math.max(stackY, vp.rect.bottom + 10);
      }
    }

    // Clamp to viewport
    return {
      x: Math.max(10, Math.min(x, viewWidth - panelWidth - 10)),
      y: Math.max(minY, Math.min(stackY, viewHeight - 200)),
    };
  }

  // Panel visibility toggle
  window.togglePanel = function (id) {
    const panel = document.getElementById("panel-" + id);
    if (!panel) return;

    const isVisible = panel.style.display !== "none";

    if (isVisible) {
      // Closing: save current position
      const rect = panel.getBoundingClientRect();
      if (panelState[id]) {
        panelState[id].x = rect.left;
        panelState[id].y = rect.top;
        panelState[id].hasUserPosition = true;
      }
      panel.style.display = "none";
    } else {
      // Opening: restore user position OR use smart stacking
      if (
        panelState[id] &&
        panelState[id].hasUserPosition &&
        panelState[id].x !== null
      ) {
        panel.style.left = panelState[id].x + "px";
        panel.style.top = panelState[id].y + "px";
      } else {
        const pos = getSmartPosition(id);
        panel.style.left = pos.x + "px";
        panel.style.top = pos.y + "px";
      }
      panel.style.display = "block";

      // Ensure panel content reflects latest state when opening.
      // The Image panel depends on global state (e.g. presets can inject a logo).
      if (id === "image" && typeof window.refreshImagePanelUI === "function") {
        window.refreshImagePanelUI();
      }
    }

    const btn = document.getElementById("tool-" + id);
    if (btn) btn.classList.toggle("active", !isVisible);
  };

  // Close panel function
  window.closePanel = function (id) {
    const panel = document.getElementById("panel-" + id);
    if (panel && panel.style.display !== "none") {
      // Save position before closing
      const rect = panel.getBoundingClientRect();
      if (panelState[id]) {
        panelState[id].x = rect.left;
        panelState[id].y = rect.top;
        panelState[id].hasUserPosition = true;
      }
      panel.style.display = "none";
    }

    const btn = document.getElementById("tool-" + id);
    if (btn) btn.classList.remove("active");
  };

  // Color update functions (QR-specific, but commonly used)
  // NOTE: applyPreset for COLORS is now applyColorPreset to avoid conflict with StylePanel's applyPreset
  window.updateColor = function (type, value) {
    if (window.state && window.state.config) {
      if (type === "fg") {
        window.state.config.fg = value;
      } else {
        window.state.config.bg = value;
      }
    }
    if (window.updateQR) window.updateQR();
  };

  window.applyColorPreset = function (fg, bg) {
    const fgInput = document.getElementById("color-fg");
    const bgInput = document.getElementById("color-bg");
    if (fgInput) fgInput.value = fg;
    if (bgInput) bgInput.value = bg;
    window.updateColor("fg", fg);
    window.updateColor("bg", bg);
  };

  // Drag functionality with position tracking
  (function () {
    let dragTarget = null;
    let dragOffset = { x: 0, y: 0 };

    document.addEventListener("mousedown", function (e) {
      let el = e.target;
      while (el && !el.classList.contains("drag-handle")) {
        if (
          el.classList.contains("panel-close") ||
          el.tagName === "BUTTON" ||
          el.tagName === "INPUT" ||
          el.tagName === "SELECT"
        ) {
          return;
        }
        el = el.parentElement;
      }

      if (el && el.classList.contains("drag-handle")) {
        e.preventDefault();
        dragTarget = el.closest(".tool-panel");
        if (dragTarget) {
          const rect = dragTarget.getBoundingClientRect();
          dragOffset.x = e.clientX - rect.left;
          dragOffset.y = e.clientY - rect.top;
          dragTarget.style.transition = "none";
        }
      }
    });

    document.addEventListener("mousemove", function (e) {
      if (dragTarget) {
        e.preventDefault();
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        dragTarget.style.left = x + "px";
        dragTarget.style.top = y + "px";

        // Mark as user-positioned
        const panelId = dragTarget.id.replace("panel-", "");
        if (panelState[panelId]) {
          panelState[panelId].hasUserPosition = true;
        }
      }
    });

    document.addEventListener("mouseup", function () {
      if (dragTarget) {
        // Save final position
        const panelId = dragTarget.id.replace("panel-", "");
        if (panelState[panelId]) {
          const rect = dragTarget.getBoundingClientRect();
          panelState[panelId].x = rect.left;
          panelState[panelId].y = rect.top;
        }
        dragTarget.style.transition = "";
        dragTarget = null;
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      if (typeof panelIds !== "undefined" && Array.isArray(panelIds)) {
        panelIds.forEach((id) => {
          const btn = document.getElementById("tool-" + id);
          if (btn) {
            btn.addEventListener("click", function () {
              if (window.togglePanel) window.togglePanel(id);
            });
          }
        });
      }
    });
  })();
</script>
