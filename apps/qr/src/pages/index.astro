---
// QRHoli V4 - Bento Grid Sovereign UX
import "../styles/app.css";
import EditorCanvas from "../components/EditorCanvas.astro";
import HUDControls from "../components/HUDControls.astro";

const lang = "es";
---

<html lang={lang}>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Holi QR - Sovereign Bento</title>

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <!-- jsQR for scan verification -->
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  </head>
  <body>
    <div class="app-layout">
      <!-- HUD is now nested inside EditorCanvas -->
      <EditorCanvas />
    </div>

    <script>
      import {
        downloadBlob,
        state,
        initWasm,
        generateSVG,
        exportPNG,
        exportPDF,
      } from "../lib/qr-engine";
      import { getTypeLogo, getColorizedTypeLogo } from "../lib/brand-logos";

      // View State
      let currentView = "type-selection"; // type-selection | input-form | qr-result

      // Initialize WASM
      initWasm().then((ready) => {
        if (ready && state.text) {
          updateQR();
        }
        // Initial state is already correct (type grid visible)
      });

      // DOM Refs
      const els = {
        generateBtn: document.getElementById(
          "generate-btn"
        ) as HTMLButtonElement,
        resetBtn: document.getElementById("btn-reset") as HTMLButtonElement,
        canvas: document.getElementById("canvas-container") as HTMLElement,
        qr: document.getElementById("qr-frame") as HTMLElement,
        fg: document.getElementById("color-fg") as HTMLInputElement,
        bg: document.getElementById("color-bg") as HTMLInputElement,
        // Input fields for each type
        urlInput: document.getElementById("input-url") as HTMLInputElement,
        textInput: document.getElementById("input-text") as HTMLTextAreaElement,
        wifiSsid: document.getElementById(
          "input-wifi-ssid"
        ) as HTMLInputElement,
        wifiPass: document.getElementById(
          "input-wifi-pass"
        ) as HTMLInputElement,
        wifiEnc: document.getElementById("input-wifi-enc") as HTMLSelectElement,
        vcardName: document.getElementById(
          "input-vcard-name"
        ) as HTMLInputElement,
        vcardPhone: document.getElementById(
          "input-vcard-phone"
        ) as HTMLInputElement,
        vcardEmail: document.getElementById(
          "input-vcard-email"
        ) as HTMLInputElement,
        vcardCompany: document.getElementById(
          "input-vcard-company"
        ) as HTMLInputElement,
        // New inputs
        appstoreInput: document.getElementById(
          "input-appstore"
        ) as HTMLInputElement,
        playstoreInput: document.getElementById(
          "input-playstore"
        ) as HTMLInputElement,
        fbInput: document.getElementById("input-fb") as HTMLInputElement,
        twitterInput: document.getElementById(
          "input-twitter"
        ) as HTMLInputElement,
        ytInput: document.getElementById("input-yt") as HTMLInputElement,
      };

      // Expose state globally for panels
      (window as any).state = state;

      // --- Listeners ---

      // Button listeners
      els.generateBtn?.addEventListener("click", () => generateQR());
      els.resetBtn?.addEventListener("click", resetToZero);

      const verifyBtn = document.getElementById("btn-verify");
      if (verifyBtn) {
        verifyBtn.addEventListener("click", () => verifyScan());
      }

      const copyBtn = document.getElementById("btn-copy");
      if (copyBtn) {
        copyBtn.addEventListener("click", () => copyQRToClipboard());
      }

      // Copy QR as PNG image to clipboard
      async function copyQRToClipboard() {
        if (!state.text) return;
        const svg = els.qr?.querySelector("svg");
        if (!svg) return;

        try {
          const svgData = new XMLSerializer().serializeToString(svg);
          const blob = await exportPNG(svgData, exportSize);
          await navigator.clipboard.write([
            new ClipboardItem({ "image/png": blob }),
          ]);

          // Visual feedback
          const btn = document.getElementById("btn-copy");
          if (btn) {
            btn.classList.add("success");
            setTimeout(() => btn.classList.remove("success"), 1500);
          }
        } catch (e) {
          console.error("Copy failed:", e);
          alert("Copy failed. Try using Download instead.");
        }
      }

      // Debounced auto-generate on input change (real-time updates)
      let inputDebounceTimer: ReturnType<typeof setTimeout> | null = null;
      function debouncedAutoGenerate() {
        if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
        inputDebounceTimer = setTimeout(() => {
          const content = getContentData();
          if (content) {
            generateQR(true); // immediate render for real-time updates
          }
        }, 300); // 300ms debounce for responsive feel
      }

      document.querySelectorAll(".input-field").forEach((input) => {
        input.addEventListener("input", debouncedAutoGenerate);
        // Keep Enter for immediate generation
        input.addEventListener("keydown", (e) => {
          if (
            (e as KeyboardEvent).key === "Enter" &&
            !(e.target as HTMLElement).matches("textarea")
          ) {
            if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
            generateQR();
          }
        });
      });

      // --- Core Logic ---

      function getContentData(): string {
        const type = (window as any).currentContentType || "url";

        switch (type) {
          case "url":
            return els.urlInput?.value.trim() || "";
          case "text":
            return els.textInput?.value.trim() || "";
          case "wifi":
            const ssid = els.wifiSsid?.value.trim() || "";
            const pass = els.wifiPass?.value.trim() || "";
            const enc = els.wifiEnc?.value || "WPA";
            if (!ssid) return "";
            return `WIFI:S:${ssid};T:${enc};P:${pass};;`;
          case "vcard":
            const name = els.vcardName?.value.trim() || "";
            const phone = els.vcardPhone?.value.trim() || "";
            const email = els.vcardEmail?.value.trim() || "";
            const company = els.vcardCompany?.value.trim() || "";
            if (!name) return "";
            return `BEGIN:VCARD\nVERSION:3.0\nN:${name}\nFN:${name}\nTEL:${phone}\nEMAIL:${email}\nORG:${company}\nEND:VCARD`;
          case "appstore":
            return els.appstoreInput?.value.trim() || "";
          case "playstore":
            return els.playstoreInput?.value.trim() || "";
          case "facebook":
            return els.fbInput?.value.trim() || "";
          case "twitter":
            return els.twitterInput?.value.trim() || "";
          case "youtube":
            return els.ytInput?.value.trim() || "";
          default:
            return "";
        }
      }

      function generateQR(immediate: boolean = false) {
        const content = getContentData();
        if (!content) return;

        state.text = content;

        // If canvas already has "generating" class, just render immediately (real-time mode)
        if (els.canvas?.classList.contains("generating") || immediate) {
          renderQR();
          debouncedVerifyScan();
        } else {
          // First time: add generating class and animate
          els.canvas?.classList.add("generating");
          setTimeout(() => {
            renderQR();
            debouncedVerifyScan();
          }, 400);
        }
      }

      function resetToZero() {
        // Clear all inputs
        state.text = "";
        if (els.urlInput) els.urlInput.value = "";
        if (els.textInput) els.textInput.value = "";
        if (els.wifiSsid) els.wifiSsid.value = "";
        if (els.wifiPass) els.wifiPass.value = "";
        if (els.vcardName) els.vcardName.value = "";
        if (els.vcardPhone) els.vcardPhone.value = "";
        if (els.vcardEmail) els.vcardEmail.value = "";
        if (els.vcardCompany) els.vcardCompany.value = "";
        if (els.qr) els.qr.innerHTML = "";

        els.canvas?.classList.remove("generating");

        // Reset to URL type
        if ((window as any).setContentType) {
          (window as any).setContentType("url");
        }
        removeLogo(); // Clear logo on reset
      }

      function renderQR() {
        if (!state.text || !els.qr) return;

        // Ensure DOM inputs match state if they exist (sync back)
        if (
          els.fg &&
          els.fg.value !== state.config.fg &&
          !state.config.fg.startsWith("trans")
        )
          els.fg.value = state.config.fg;
        if (
          els.bg &&
          els.bg.value !== state.config.bg &&
          !state.config.bg.startsWith("trans")
        )
          els.bg.value = state.config.bg;

        els.qr.innerHTML = generateSVG(state.text, state.config);

        // Auto-verify after each render (debounced)
        debouncedVerifyScan();
      }

      // Legacy updateQR
      function updateQR() {
        renderQR();
      }

      function updateScanStatus(
        status: "valid" | "invalid" | "checking" | "none"
      ) {
        // Update toolbar button
        const btn = document.getElementById("btn-verify");
        const icon = document.getElementById("verify-icon");
        if (btn && icon) {
          btn.classList.remove("valid", "invalid", "checking");

          if (status === "checking") {
            btn.classList.add("checking");
            icon.textContent = "hourglass_empty";
            btn.title = "Checking...";
          } else if (status === "valid") {
            btn.classList.add("valid");
            icon.textContent = "check_circle";
            btn.title = "QR Scannable";
          } else if (status === "invalid") {
            btn.classList.add("invalid");
            icon.textContent = "error";
            btn.title = "QR Unreadable";
          } else {
            icon.textContent = "verified_user";
            btn.title = "Verify QR";
          }
        }

        // Update Style panel readable status
        const styleIcon = document.getElementById("style-status-icon");
        const styleText = document.getElementById("style-status-text");
        const styleStatus = document.getElementById("style-readable-status");
        if (styleIcon && styleText && styleStatus) {
          styleStatus.classList.remove("valid", "invalid", "checking");
          if (status === "checking") {
            styleStatus.classList.add("checking");
            styleIcon.textContent = "⏳";
            styleText.textContent = "Checking...";
          } else if (status === "valid") {
            styleStatus.classList.add("valid");
            styleIcon.textContent = "✅";
            styleText.textContent = "QR is readable";
          } else if (status === "invalid") {
            styleStatus.classList.add("invalid");
            styleIcon.textContent = "❌";
            styleText.textContent = "QR not readable";
          }
        }
      }

      // Debounce timer for scan verification
      let scanDebounceTimer: ReturnType<typeof setTimeout> | null = null;

      function debouncedVerifyScan() {
        if (scanDebounceTimer) clearTimeout(scanDebounceTimer);
        // Wait until user stops changing before showing "checking"
        scanDebounceTimer = setTimeout(() => {
          updateScanStatus("checking");
          verifyScan();
        }, 500); // 500ms debounce
      }

      // Auto-verify on render
      const originalRender = renderQR;
      // Overwrite renderQR to include verification
      // (This creates a slight recursion loop if not careful, but debouncedVerifyScan is safe)
      // Actually, let's just add it to the end of the existing renderQR function
      // But I can't easily append to function in this replace tool without replacing whole function...
      // I'll just call debouncedVerifyScan() at end of generateQR or create a hook.
      // Better: add it to generateQR and updateColor etc.

      // We will add debouncedVerifyScan() call inside the 'renderQR' function above if I could edit it again.
      // OR better, since I replaced renderQR lines 180-184 above, I should have added it there.
      // Let's add a watcher or just call it where needed.
      // For now, let's hooking into updateQR aliases.

      // Override the updateQR exposed to window to also verify
      (window as any).updateQR = function () {
        renderQR();
        debouncedVerifyScan();
      };

      async function verifyScan() {
        if (!state.text) return;

        // Wait for SVG to render

        const svg = els.qr?.querySelector("svg");
        if (!svg) {
          updateScanStatus("invalid");
          return;
        }

        try {
          // Convert SVG to canvas
          const svgData = new XMLSerializer().serializeToString(svg);
          const svgBlob = new Blob([svgData], {
            type: "image/svg+xml;charset=utf-8",
          });
          const url = URL.createObjectURL(svgBlob);

          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            const size = 300; // Fixed size for scanning
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext("2d");
            if (!ctx) {
              updateScanStatus("invalid");
              return;
            }

            // Draw white background first
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, size, size);
            ctx.drawImage(img, 0, 0, size, size);

            const imageData = ctx.getImageData(0, 0, size, size);

            // Use jsQR to scan
            // @ts-ignore - jsQR is loaded from CDN
            const code = window.jsQR(imageData.data, size, size);

            if (code && code.data) {
              updateScanStatus("valid");
            } else {
              updateScanStatus("invalid");
            }

            URL.revokeObjectURL(url);
          };

          img.onerror = () => {
            updateScanStatus("invalid");
            URL.revokeObjectURL(url);
          };

          img.src = url;
        } catch (e) {
          console.error("Scan verification failed:", e);
          updateScanStatus("invalid");
        }
      }

      // 3-Layer Shape Setters
      function setBodyShape(s: string) {
        state.config.bodyShape = s as any;
        document
          .querySelectorAll("[data-bodyshape]")
          .forEach((b) =>
            b.classList.toggle(
              "active",
              (b as HTMLElement).dataset.bodyshape === s
            )
          );
        updateQR();
      }

      function setEyeFrame(s: string) {
        state.config.eyeFrameShape = s as any;
        document
          .querySelectorAll("[data-eyeframe]")
          .forEach((b) =>
            b.classList.toggle(
              "active",
              (b as HTMLElement).dataset.eyeframe === s
            )
          );
        updateQR();
      }

      function setEyeBall(s: string) {
        state.config.eyeBallShape = s as any;
        document
          .querySelectorAll("[data-eyeball]")
          .forEach((b) =>
            b.classList.toggle(
              "active",
              (b as HTMLElement).dataset.eyeball === s
            )
          );
        updateQR();
      }

      // Legacy alias for backwards compatibility
      function setShape(s: string) {
        setBodyShape(s);
      }

      function setEcc(e: string) {
        state.config.ecc = e as any;
        document
          .querySelectorAll("[data-ecc]")
          .forEach((b) =>
            b.classList.toggle("active", (b as HTMLElement).dataset.ecc === e)
          );
        updateQR();
      }
      (window as any).setEcc = setEcc;

      function showRecent() {
        if (state.recent.length === 0) return;
        // Logic to show recent overlay
        const recentView = document.getElementById("recent-view");
        if (recentView) recentView.classList.add("active");
        renderRecent();
      }

      function renderRecent() {
        const grid = document.getElementById("recent-grid");
        if (!grid) return;
        grid.innerHTML = state.recent
          .map(
            (r) => `
            <div class="grid-card" onclick="window.loadRecent('${r.id}')">
              <div style="aspect-ratio:1;background:${r.config.bg};border-radius:4px;padding:4px;margin-bottom:8px">
                ${generateSVG(r.text, r.config)}
              </div>
              <div style="font-size:11px;font-weight:600;white-space:nowrap;overflow:hidden;color:var(--text-main)">${r.name}</div>
            </div>
          `
          )
          .join("");
      }

      function loadRecent(id: string) {
        const r = state.recent.find((x) => x.id === id);
        if (r) {
          state.text = r.text;
          state.config = { ...r.config };
          // Update input field
          // Update input field
          if (els.urlInput) els.urlInput.value = r.text;
          if (els.textInput) els.textInput.value = r.text;
          if (els.fg) els.fg.value = r.config.fg;
          if (els.bg) els.bg.value = r.config.bg;
          setShape(r.config.bodyShape);
          setEcc(r.config.ecc);
          // Show result
          generateQR();
        }
      }

      function downloadQR() {
        if (!state.text) return;
        const blob = new Blob([generateSVG(state.text, state.config)], {
          type: "image/svg+xml",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "qr-code.svg";
        a.click();
      }

      // DPI state
      let currentDpi = 300;

      let exportSize = 1000;

      function setExportSize(val: string) {
        exportSize = parseInt(val);
        const el = document.getElementById("export-size-val");
        if (el) el.textContent = exportSize + " px";
      }

      async function downloadPNG() {
        if (!state.text) return;
        const svg = els.qr?.querySelector("svg");
        if (!svg) return;

        const svgData = new XMLSerializer().serializeToString(svg);
        try {
          const blob = await exportPNG(svgData, exportSize);
          downloadBlob(blob, `qr-${Date.now()}.png`);
        } catch (e) {
          console.error(e);
          alert("Export failed");
        }
      }

      async function downloadPDF() {
        if (!state.text) return;
        const svg = els.qr?.querySelector("svg");
        if (!svg) return;

        const svgData = new XMLSerializer().serializeToString(svg);
        try {
          const blob = await exportPDF(svgData);
          downloadBlob(blob, `qr-${Date.now()}.pdf`);
        } catch (e) {
          console.error(e);
          alert("Export failed");
        }
      }

      // Unified download function for menu
      async function downloadAs(format: string) {
        if (!state.text) return;
        const svg = els.qr?.querySelector("svg");
        if (!svg) return;

        const svgData = new XMLSerializer().serializeToString(svg);

        // Close menu
        const menu = document.getElementById("download-menu");
        if (menu) menu.classList.remove("show");

        try {
          let blob: Blob;
          let ext: string;

          switch (format) {
            case "svg":
              blob = new Blob([svgData], { type: "image/svg+xml" });
              ext = "svg";
              break;
            case "png":
              blob = await exportPNG(svgData, exportSize);
              ext = "png";
              break;
            case "jpg":
              // Export as PNG then convert - or use canvas with white bg
              blob = await exportPNG(svgData, exportSize);
              ext = "jpg"; // Note: actual conversion to jpg would need additional work
              break;
            case "pdf":
              blob = await exportPDF(svgData);
              ext = "pdf";
              break;
            default:
              blob = new Blob([svgData], { type: "image/svg+xml" });
              ext = "svg";
          }

          downloadBlob(blob, `qr-${Date.now()}.${ext}`);
        } catch (e) {
          console.error(e);
          alert("Export failed: " + e);
        }
      }
      (window as any).downloadAs = downloadAs;

      // Download menu toggle (handled in EditorCanvas script)

      // Logo handlers
      function handleLogoUpload(event: Event) {
        const input = event.target as HTMLInputElement;
        const file = input.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target?.result as string;
          state.config.logo = dataUrl;

          // Auto-switch to ECC H for better error correction
          state.config.ecc = "H";
          document
            .querySelectorAll("[data-ecc]")
            .forEach((b) =>
              b.classList.toggle(
                "active",
                (b as HTMLElement).dataset.ecc === "H"
              )
            );

          // Update UI
          const preview = document.getElementById("logo-preview");
          const placeholder = document.getElementById("logo-placeholder");
          const img = document.getElementById("logo-img") as HTMLImageElement;
          const area = document.getElementById("logo-upload-area");

          if (preview && placeholder && img && area) {
            img.src = dataUrl;
            preview.style.display = "block";
            placeholder.style.display = "none";
            area.classList.add("has-logo");
          }

          updateQR();
        };
        reader.readAsDataURL(file);
      }

      function removeLogo() {
        state.config.logo = undefined;

        const preview = document.getElementById("logo-preview");
        const placeholder = document.getElementById("logo-placeholder");
        const area = document.getElementById("logo-upload-area");
        const input = document.getElementById("logo-input") as HTMLInputElement;

        if (preview && placeholder && area && input) {
          preview.style.display = "none";
          placeholder.style.display = "flex";
          area.classList.remove("has-logo");
          input.value = "";
        }

        updateQR();
      }

      // Frame/CTA handlers (Sprint 3)
      let currentFrame = "none";
      let currentCTA = "";

      function setFrame(frame: string) {
        currentFrame = frame;
        document
          .querySelectorAll("[data-frame]")
          .forEach((b) =>
            b.classList.toggle(
              "active",
              (b as HTMLElement).dataset.frame === frame
            )
          );
        // Frame rendering will be added in SVG export
      }

      function updateCTA(text: string) {
        currentCTA = text;
        // CTA will be rendered with frame
      }

      // Transparent color toggle
      let fgTransparent = false;
      let bgTransparent = false;

      // Toggle background transparency (used by Color panel)
      function toggleBgTransparent(isChecked: boolean) {
        bgTransparent = isChecked;
        state.config.bg = isChecked
          ? "transparent"
          : els.bg?.value || "#ffffff";

        // Toggle qr-frame visual transparency
        const qrFrame = document.getElementById("qr-frame");
        if (qrFrame) {
          qrFrame.classList.toggle("transparent-bg", isChecked);
        }

        updateQR();
      }
      (window as any).toggleBgTransparent = toggleBgTransparent;

      // Set mask pattern (used by Advanced panel)
      function setMaskPattern(value: string) {
        state.config.mask = value === "auto" ? undefined : parseInt(value);
        updateQR();
      }
      (window as any).setMaskPattern = setMaskPattern;

      // Legacy toggleTransparent for backwards compatibility
      function toggleTransparent(isChecked: boolean) {
        toggleBgTransparent(isChecked);
      }

      // Legacy toggle transparent (if still used by old code)
      // We kept the function signature compatible if possible but the UI changed
      // (window as any).toggleTransparent = toggleTransparent;

      // Updated setLogoSize for slider
      function setLogoSize(size: number) {
        state.config.logoSize = size;
        const valueEl = document.getElementById("logo-size-value");
        if (valueEl) valueEl.textContent = Math.round(size * 100) + "%";
        updateQR();
      }

      // ========================================
      // UX OVERHAUL: New Functions
      // ========================================

      // HUD & Interaction Logic ---

      function closeHudPanels() {
        document
          .querySelectorAll(".hud-panel")
          .forEach((p) => p.classList.remove("active"));
        document
          .querySelectorAll(".hud-btn")
          .forEach((b) => b.classList.remove("active"));
      }

      function toggleHudPanel(id: string) {
        if (id === "content") {
          // Content button resets to start
          resetToZero();
          return;
        }

        const panel = document.getElementById(`hud-panel-${id}`);
        // Close others
        document.querySelectorAll(".hud-panel").forEach((p) => {
          if (p.id !== `hud-panel-${id}`) p.classList.remove("active");
        });
        document
          .querySelectorAll(".hud-btn")
          .forEach((b) => b.classList.remove("active"));

        // Toggle current
        if (panel) {
          const isActive = panel.classList.contains("active");
          if (isActive) {
            panel.classList.remove("active");
          } else {
            panel.classList.add("active");
          }
        }
      }

      function showHudContentForm(type: string) {
        // Simplified: just alert for non-URL types
        console.log("Type selected:", type);
        alert("Only Text/URL type is implemented.");
      }

      function showHudContentGrid() {
        resetToZero();
      }

      // Placeholder functions
      function toggleTheme() {
        document.body.classList.toggle("light-theme");
      }

      function toggleLang() {}
      function undo() {}
      function redo() {}
      function setCanvasBg() {}
      function zoomIn() {}
      function zoomOut() {}
      function toggleSidebar() {}
      function switchTab() {}

      // Expose to window
      (window as any).setShape = setShape; // Legacy
      (window as any).setBodyShape = setBodyShape;
      (window as any).setEyeFrame = setEyeFrame;

      // Centralized Logo Handler
      function setLogo(dataUrl: string) {
        // If dataUrl is a preset (id), get the correct version based on state
        const type = (window as any).currentContentType;
        
        state.config.logo = dataUrl;

        // Auto-increase ECC for logos if not already high
        setEcc("H");

        // Default logo size if not set
        if (!state.config.logoSize) {
          state.config.logoSize = 0.2;
        }

        updateLogoUI();
        updateQR();
      }

      function updateLogoUI() {
        const preview = document.getElementById("logo-preview");
        const placeholder = document.getElementById("logo-placeholder");
        const img = document.getElementById("logo-img") as HTMLImageElement;
        const area = document.getElementById("logo-upload-area");

        if (preview && placeholder && img && area) {
          if (state.config.logo) {
            img.src = state.config.logo;
            preview.style.display = "block";
            placeholder.style.display = "none";
            area.classList.add("has-logo");
          } else {
            preview.style.display = "none";
            placeholder.style.display = "flex";
            area.classList.remove("has-logo");
          }
        }
        
        // Update controls
        const bgToggle = document.getElementById("logo-bg-toggle") as HTMLInputElement;
        if (bgToggle) bgToggle.checked = !!state.config.logoBgToggle;
      }

      function setLogoColor(color: string) {
        state.config.logoColor = color;
        
        // Re-calculate the logo data URI based on color
        const type = (window as any).currentContentType;
        if (type) {
           applyTypeLogo(type);
        }
        
        updateQR();
      }
      (window as any).setLogoColor = setLogoColor;

      function toggleLogoBg(checked: boolean) {
        state.config.logoBgToggle = checked;
        updateQR();
      }
      (window as any).toggleLogoBg = toggleLogoBg;

      function applyTypeLogo(type: string) {
        const color = state.config.logoColor || 'original';
        let logo;
        
        if (color === 'original') {
          logo = getTypeLogo(type);
        } else {
          logo = getColorizedTypeLogo(type, color);
        }
        
        if (logo) {
          setLogo(logo);
        }
      }
      (window as any).getColorizedTypeLogo = getColorizedTypeLogo;

      // Auto-set logo when type changes (Event Driven)
      window.addEventListener("qr-type-changed", (e: any) => {
        const type = e.detail?.type;
        if (!type) return;

        console.log("QR Type Changed:", type);
        applyTypeLogo(type);
      });

      // Update manual upload to use same function
      (window as any).handleLogoUpload = (event: Event) => {
        const input = event.target as HTMLInputElement;
        if (input.files && input.files[0]) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const dataUrl = e.target?.result as string;
            setLogo(dataUrl);
          };
          reader.readAsDataURL(input.files[0]);
        }
      };

      (window as any).setLogo = setLogo; // Expose for debugging
      (window as any).showRecent = showRecent;
      (window as any).loadRecent = loadRecent;
      (window as any).downloadQR = downloadQR;
      (window as any).setExportSize = setExportSize;
      (window as any).downloadPDF = downloadPDF;
      (window as any).downloadPNG = downloadPNG;
      // handleLogoUpload already assigned above

      (window as any).removeLogo = removeLogo;
      (window as any).setLogoSize = setLogoSize;
      (window as any).setFrame = setFrame;
      (window as any).updateCTA = updateCTA;
      (window as any).toggleTransparent = toggleTransparent;
      (window as any).toggleTheme = toggleTheme;
      (window as any).toggleLang = toggleLang;
      // HUD Handlers
      (window as any).toggleHudPanel = toggleHudPanel;
      (window as any).closeHudPanels = closeHudPanels;
      (window as any).showHudContentForm = showHudContentForm;
      (window as any).showHudContentGrid = showHudContentGrid;
      // Core Handlers
      (window as any).updateQR = updateQR;
      (window as any).generateQR = generateQR;
      (window as any).resetToZero = resetToZero;
    </script>
  </body>
</html>
