---
import BaseLayout from "@holi/ui/src/layouts/BaseLayout.astro";
import GlassCard from "@holi/ui/src/components/GlassCard.astro";
import Icon from "@holi/ui/src/components/Icon.astro";

export function getStaticPaths() {
  return [{ params: { lang: "en" } }, { params: { lang: "es" } }];
}

const { lang } = Astro.params;

const title =
  lang === "es" ? "El Motor <10KB: Adiós GPU" : "The <10KB Engine: Bye GPU";
const date = "2024-01-08";
---

<html lang={lang}>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title} - Holi Papers</title>
  </head>
  <body>
    <BaseLayout
      title={title}
      lang={lang}
      languages={[
        { code: "en", name: "English" },
        { code: "es", name: "Español" },
      ]}
      colorScheme="qr"
    >
      <!-- Progress Bar (Fake/Scroll based) -->
      <div
        class="fixed top-0 left-0 h-1 bg-[var(--color-accent)] z-[100] w-full origin-left scale-x-0 transition-transform duration-100"
        id="reading-progress"
      >
      </div>

      <article class="max-w-3xl mx-auto px-4 pt-32 pb-32">
        <!-- Header -->
        <header class="mb-16 text-center">
          <div
            class="inline-flex items-center gap-2 px-3 py-1 rounded-full border border-white/10 bg-white/5 text-xs font-mono text-white/60 mb-6"
          >
            <span>{date}</span>
            <span>•</span>
            <span>ENGINEERING</span>
          </div>
          <h1
            class="text-4xl md:text-6xl font-black mb-6 tracking-tight leading-tight text-white"
          >
            {title}
          </h1>
          <p class="text-xl text-white/60 leading-relaxed max-w-2xl mx-auto">
            {
              lang === "es"
                ? "Cómo redujimos el tamaño del bundle en un 99% reemplazando WebGPU con matemáticas vectoriales puras en Rust."
                : "How we slashed bundle size by 99% by replacing WebGPU with pure vector math in Rust."
            }
          </p>
        </header>

        <!-- Content -->
        <div
          class="prose prose-invert prose-lg mx-auto prose-headings:font-bold prose-headings:tracking-tight prose-a:text-[var(--color-accent)] prose-pre:bg-black/30 prose-pre:backdrop-blur prose-pre:border prose-pre:border-white/10"
        >
          {
            lang === "es" ? (
              <>
                <p>
                  Cuando empezamos <strong>Holi QR</strong>, queríamos que fuera
                  espectacular. Usamos <strong>WebGPU</strong>, la tecnología
                  gráfica más avanzada de la web. Lucía increíble. Tenía
                  brillos, partículas y "Efecto Líquido".
                </p>
                <p>
                  Pero tenía un precio: <strong>2 Megabytes</strong> de WASM.
                </p>

                <GlassCard
                  class="my-8 font-mono text-sm leading-relaxed"
                  padding="md"
                >
                  <>
                    <span class="text-red-400">- wgpu_core.wasm (2.1 MB)</span>
                    <br />
                  </>
                  <span class="text-green-400">
                    + holi_qr_svg.wasm (0.02 MB)
                  </span>
                </GlassCard>

                <h3>El Problema con la GPU para códigos 2D</h3>
                <p>
                  Usar una tarjeta gráfica para dibujar cuadrados negros (un QR)
                  es como usar un cohete espacial para cruzar la calle.
                  Funciona, y es impresionante, pero es excesivo.
                </p>
                <p>
                  Además, los QRs generados por GPU son <strong>píxeles</strong>
                  . Si haces zoom, se ven borrosos. Para imprimir
                  gigantografías, necesitas vectores (SVG).
                </p>

                <h3>La Solución: "El Camino Inteligente"</h3>
                <p>
                  En lugar de decirle a la GPU que dibuje miles de triángulos,
                  le dijimos a Rust que calculara una sola línea matemática.
                </p>
                <p>
                  Un código QR es solo una matriz de 1s y 0s. Iteramos esa
                  matriz y construimos un{" "}
                  <code class="text-[var(--color-accent)]">&lt;path&gt;</code>{" "}
                  SVG.
                </p>

                <pre class="language-rust rounded-xl overflow-hidden">
                  <code>
                    {`// Rust (Simplificado)
    pub fn generate_svg(matrix: &[bool], size: usize) -> String {
        let mut path = String::new();
        
        for y in 0..size {
            for x in 0..size {
                if matrix[y][x] {
                    // Mueve al punto, dibuja 1x1
                    path.push_str(&format!("M{},{}h1v1h-1z ", x, y));
                }
            }
        }
        
        format!("<svg ...><path d='{}'/></svg>", path)
    }`}
                  </code>
                </pre>

                <h3>Resultados</h3>
                <ul>
                  <li>
                    <strong>Peso:</strong> 27KB (antes 2.1MB)
                  </li>
                  <li>
                    <strong>Calidad:</strong> Infinita (Vectorial)
                  </li>
                  <li>
                    <strong>Velocidad:</strong> Instantánea (No espera a
                    inicializar GPU)
                  </li>
                </ul>

                <p>
                  A veces, la mejor ingeniería no es usar la herramienta más
                  nueva, sino la más adecuada.
                </p>
              </>
            ) : (
              <>
                <p>
                  When we started <strong>Holi QR</strong>, we wanted it to be
                  spectacular. We used <strong>WebGPU</strong>, the most
                  advanced graphics tech on the web. It looked amazing. It had
                  glows, particles, and "Liquid Effects".
                </p>
                <p>
                  But it came at a price: <strong>2 Megabytes</strong> of WASM.
                </p>

                <GlassCard
                  class="my-8 font-mono text-sm leading-relaxed"
                  padding="md"
                >
                  <>
                    <span class="text-red-400">- wgpu_core.wasm (2.1 MB)</span>
                    <br />
                  </>
                  <span class="text-green-400">
                    + holi_qr_svg.wasm (0.02 MB)
                  </span>
                </GlassCard>

                <h3>The Problem with GPU for 2D</h3>
                <p>
                  Using a graphics card to draw black squares (a QR) is like
                  using a space rocket to cross the street. It works, and it's
                  impressive, but it's overkill.
                </p>
                <p>
                  Also, GPU-generated QRs are <strong>pixels</strong>. If you
                  zoom in, they get blurry. For printing billboards, you need
                  vectors (SVG).
                </p>

                <h3>The Solution: "The Smart Path"</h3>
                <p>
                  Instead of telling the GPU to draw thousands of triangles, we
                  told Rust to calculate a single mathematical line.
                </p>
                <p>
                  A QR code is just a matrix of 1s and 0s. We iterate that
                  matrix and construct an SVG{" "}
                  <code class="text-[var(--color-accent)]">&lt;path&gt;</code>.
                </p>

                <pre class="language-rust rounded-xl overflow-hidden">
                  <code>
                    {`// Rust (Simplified)
    pub fn generate_svg(matrix: &[bool], size: usize) -> String {
        let mut path = String::new();
        
        for y in 0..size {
            for x in 0..size {
                if matrix[y][x] {
                    // Move to point, draw 1x1 rect
                    path.push_str(&format!("M{},{}h1v1h-1z ", x, y));
                }
            }
        }
        
        format!("<svg ...><path d='{}'/></svg>", path)
    }`}
                  </code>
                </pre>

                <h3>Results</h3>
                <ul>
                  <li>
                    <strong>Size:</strong> 27KB (down from 2.1MB)
                  </li>
                  <li>
                    <strong>Quality:</strong> Infinite (Vector)
                  </li>
                  <li>
                    <strong>Speed:</strong> Instant (No GPU initialization wait)
                  </li>
                </ul>

                <p>
                  Sometimes, the best engineering isn't using the newest tool,
                  but the right one.
                </p>
              </>
            )
          }
        </div>

        <!-- Footer / Next Paper -->
        <div
          class="mt-20 pt-10 border-t border-white/10 flex justify-between items-center"
        >
          <a
            href={`/${lang}/papers`}
            class="text-white/40 hover:text-white transition-colors flex items-center gap-2"
          >
            <Icon name="arrow_back" size={16} />
            Back to Papers
          </a>
        </div>
      </article>
    </BaseLayout>

    <script>
      window.addEventListener("scroll", () => {
        const scraped = window.scrollY;
        const total =
          document.documentElement.scrollHeight - window.innerHeight;
        const progress = document.getElementById("reading-progress");
        if (progress) {
          progress.style.transform = `scaleX(${scraped / total})`;
        }
      });
    </script>
  </body>
</html>
