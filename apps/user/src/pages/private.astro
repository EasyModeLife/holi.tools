---
import VaultLayout from "../layouts/VaultLayout.astro";
import ChatPanel from "../components/ChatPanel.astro";

const lang = Astro.currentLocale || "en";
const basePath = lang === "en" ? "" : `/${lang}`;
---

<VaultLayout title="Private Chat">
  <div class="max-w-2xl mx-auto space-y-6">
    <div class="text-center space-y-2">
      <h1 class="text-3xl font-bold text-white">Private Chat</h1>
      <p class="text-zinc-400">
        Share a one-time link to start a private P2P chat. Nostr is used only for signaling.
      </p>
      <p class="text-xs text-zinc-500">
        Tip: If you open a vault, chat history can be saved under <span class="font-mono">.holi/dm/</span>.
      </p>
    </div>

    <div class="glass-card p-5 rounded-2xl space-y-3">
      <div class="flex flex-col sm:flex-row gap-2">
        <button
          id="create-link"
          class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-colors"
        >
          Create chat link
        </button>
        <button
          id="copy-link"
          class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg font-medium transition-colors disabled:opacity-60"
          disabled
        >
          Copy
        </button>
      </div>

      <input
        id="chat-link"
        type="text"
        readonly
        class="w-full px-4 py-2 bg-black/30 rounded-lg border border-white/10 text-white font-mono text-sm"
        placeholder="Link will appear here"
      />

      <div id="status" class="text-sm text-zinc-300"></div>
    </div>

    <div class="text-center">
      <a href={`${basePath}/`} class="text-sm text-zinc-500 hover:text-white">Back to Dashboard</a>
    </div>

    <div id="chat-wrap" class="hidden">
      <ChatPanel connected={false} />
    </div>
  </div>
</VaultLayout>

<style>
  .glass-card {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
  }
</style>

<script>
  import { ChatManager } from "../lib/p2p/chat";
  import type { ChatEvent } from "../lib/p2p/chat";
  import { connectFriendDmChannel } from "../lib/friends/p2p";
  import { generateDmConfig, dmKeyBytes } from "../lib/friends/dm";
  import { getActiveHandle, getLastVault, checkAccess, restoreSession } from "../lib/workspace";
  import { listDmMessages, saveDmMessage } from "../lib/friends/dm";

  const btnCreate = document.getElementById('create-link') as HTMLButtonElement | null;
  const btnCopy = document.getElementById('copy-link') as HTMLButtonElement | null;
  const linkInput = document.getElementById('chat-link') as HTMLInputElement | null;
  const statusEl = document.getElementById('status');
  const chatWrap = document.getElementById('chat-wrap');

  let chatManager: ChatManager | null = null;
  let current = null as null | { sessionId: string; keyB64Url: string; isInitiator: boolean };

  function setStatus(text: string) {
    if (statusEl) statusEl.textContent = text;
  }

  function makeLink(dm: { sessionId: string; keyB64Url: string }): string {
    return `${window.location.origin}/private#pc=${dm.sessionId}.${dm.keyB64Url}`;
  }

  function parseLinkHash(): { sessionId: string; keyB64Url: string } | null {
    const hash = window.location.hash.slice(1);
    if (!hash.startsWith('pc=')) return null;
    const rest = hash.slice(3);
    const [sessionId, keyB64Url] = rest.split('.', 2);
    if (!sessionId || !keyB64Url) return null;
    return { sessionId, keyB64Url };
  }

  async function tryRestoreVault() {
    if (getActiveHandle()) return;
    const last = await getLastVault();
    if (!last) return;
    const status = await checkAccess(last.id);
    if (status === 'granted') {
      await restoreSession(last.id);
      window.dispatchEvent(new CustomEvent('workspace-restored'));
    }
  }

  function localStorageKey(sessionId: string): string {
    return `holi.privatechat.${sessionId}.messages.v1`;
  }

  async function loadHistory(sessionId: string) {
    // Vault-backed if possible, else localStorage.
    try {
      if (getActiveHandle()) {
        const msgs = await listDmMessages(sessionId);
        for (const m of msgs) {
          (window as any).addChatMessage?.(m.text, m.from === 'me' ? 'own' : 'peer');
        }
        return;
      }
    } catch {
      // fallthrough
    }

    try {
      const raw = window.localStorage.getItem(localStorageKey(sessionId));
      if (!raw) return;
      const data = JSON.parse(raw) as any;
      const msgs = Array.isArray(data?.messages) ? data.messages : [];
      for (const m of msgs) {
        if (m && typeof m.text === 'string') {
          (window as any).addChatMessage?.(m.text, m.from === 'me' ? 'own' : 'peer');
        }
      }
    } catch {
      // ignore
    }
  }

  async function persistMessage(sessionId: string, from: 'me' | 'peer', text: string) {
    const msg = { id: crypto.randomUUID(), ts: Date.now(), from, text };

    try {
      if (getActiveHandle()) {
        await saveDmMessage(sessionId, msg as any);
        return;
      }
    } catch {
      // fallthrough
    }

    try {
      const key = localStorageKey(sessionId);
      const raw = window.localStorage.getItem(key);
      const data = raw ? JSON.parse(raw) : { version: 1, messages: [] };
      const msgs = Array.isArray(data.messages) ? data.messages : [];
      msgs.push(msg);
      window.localStorage.setItem(key, JSON.stringify({ version: 1, messages: msgs }));
    } catch {
      // ignore
    }
  }

  async function connect(dm: { sessionId: string; keyB64Url: string }, isInitiator: boolean) {
    if (chatManager) return;
    current = { ...dm, isInitiator };

    if (chatWrap) chatWrap.classList.remove('hidden');

    setStatus(isInitiator ? 'Waiting for the other person to open the link…' : 'Connecting…');

    // Best-effort restore so vault-backed identity/history works when available.
    await tryRestoreVault();

    await loadHistory(dm.sessionId);

    const channel = await connectFriendDmChannel({ dm, isInitiator, timeoutMs: 2 * 60_000 });

    chatManager = new ChatManager(channel, `private:${dm.sessionId}`, {
      sessionKeyBytes: dmKeyBytes(dm.keyB64Url),
      onIncomingFileOffer: async (offer) => {
        const sizeMb = (offer.size / (1024 * 1024)).toFixed(1);
        const ok = confirm(`Receive file "${offer.filename}" (${sizeMb} MB)?`);
        return ok ? 'accept' : { decision: 'reject', reason: 'User rejected' };
      },
    });

    setStatus('P2P connected.');

    chatManager.on((event: ChatEvent) => {
      if (event.type === 'message') {
        const msg = event.message as any;
        const from = msg.senderId === 'me' ? 'me' : 'peer';
        const sender = from === 'me' ? 'own' : 'peer';
        const text = msg.content || '';
        if (!text) return;
        (window as any).addChatMessage?.(text, sender);
        void persistMessage(dm.sessionId, from, text);
      }
    });

    const form = document.getElementById('chat-form');
    const input = document.getElementById('msg-input') as HTMLInputElement | null;
    form?.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = (input?.value || '').trim();
      if (!text || !chatManager) return;
      chatManager.sendText(text);
      (window as any).addChatMessage?.(text, 'own');
      void persistMessage(dm.sessionId, 'me', text);
      if (input) input.value = '';
    });
  }

  // If opened via link, auto-connect as responder.
  const fromHash = parseLinkHash();
  if (fromHash) {
    if (linkInput) linkInput.value = makeLink(fromHash);
    if (btnCopy) btnCopy.disabled = false;
    void connect(fromHash, false).catch((e) => {
      console.error(e);
      setStatus('Failed to connect: ' + ((e as Error)?.message || String(e)));
    });
  } else {
    setStatus('Create a link and send it to the other person.');
  }

  btnCreate?.addEventListener('click', async () => {
    try {
      const dm = generateDmConfig();
      const url = makeLink(dm);
      if (linkInput) linkInput.value = url;
      if (btnCopy) btnCopy.disabled = false;

      // Set hash so refresh stays in this session.
      window.location.hash = `pc=${dm.sessionId}.${dm.keyB64Url}`;

      await connect(dm, true);
    } catch (e) {
      console.error(e);
      setStatus('Failed: ' + ((e as Error)?.message || String(e)));
    }
  });

  btnCopy?.addEventListener('click', async () => {
    const v = (linkInput?.value || '').trim();
    if (!v) return;
    await navigator.clipboard.writeText(v);
    if (btnCopy) {
      const prev = btnCopy.textContent;
      btnCopy.textContent = 'Copied!';
      window.setTimeout(() => {
        btnCopy.textContent = prev || 'Copy';
      }, 1200);
    }
  });
</script>
