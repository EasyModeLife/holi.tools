---
import VaultLayout from "../../layouts/VaultLayout.astro";
import ChatPanel from "../../components/ChatPanel.astro";
import { getLangFromUrl, useTranslations } from "../../i18n/utils";
import { SUPPORTED_LANGS } from "@holi/configs/i18n";

export function getStaticPaths() {
  return SUPPORTED_LANGS.map((lang) => ({ params: { lang } }));
}

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const basePath = lang === "en" ? "/en" : `/${lang}`;
const strings = {
  copy: t("private.copy"),
  copied: t("private.copied"),
  waiting: t("private.waiting"),
  connecting: t("private.connecting"),
  instruction: t("private.instruction"),
  connected: t("private.connected"),
  failed: t("private.failed"),
};
---

<VaultLayout title={t("private.title")}>
  <div class="max-w-2xl mx-auto space-y-6">
    <div class="text-center space-y-2">
      <h1 class="text-3xl font-bold text-white">{t("private.title")}</h1>
      <p class="text-zinc-400">
        {t("private.desc")}
      </p>
      <p class="text-xs text-zinc-500">
        {t("private.tip")}
      </p>
    </div>

    <div class="glass-card p-5 rounded-2xl space-y-3">
      <div class="flex flex-col sm:flex-row gap-2">
        <button
          id="create-link"
          class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-colors"
        >
          {t("private.create_link")}
        </button>
        <button
          id="copy-link"
          class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg font-medium transition-colors disabled:opacity-60"
          disabled
        >
          {t("private.copy")}
        </button>
      </div>

      <input
        id="chat-link"
        type="text"
        readonly
        class="w-full px-4 py-2 bg-black/30 rounded-lg border border-white/10 text-white font-mono text-sm"
        placeholder={t("private.placeholder")}
      />

      <div id="status" class="text-sm text-zinc-300"></div>
    </div>

    <div class="text-center">
      <a href={`${basePath}/`} class="text-sm text-zinc-500 hover:text-white"
        >{t("nav.dashboard")}</a
      >
    </div>

    <div id="chat-wrap" class="hidden">
      <ChatPanel connected={false} />
    </div>
  </div>
</VaultLayout>

<style>
  .glass-card {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
  }
</style>

<script define:vars={{ strings }}>
  window.privateStrings = strings;
</script>

<script>
  import { ChatManager } from "../../lib/p2p/chat";
  import type { ChatEvent } from "../../lib/p2p/chat";
  import { connectFriendDmChannel } from "../../lib/friends/p2p";
  import { generateDmConfig, dmKeyBytes } from "../../lib/friends/dm";
  import {
    getActiveHandle,
    getLastVault,
    checkAccess,
    restoreSession,
  } from "../../lib/workspace";
  import { listDmMessages, saveDmMessage } from "../../lib/friends/dm";

  const strings = (window as any).privateStrings;
  const btnCreate = document.getElementById(
    "create-link"
  ) as HTMLButtonElement | null;
  const btnCopy = document.getElementById(
    "copy-link"
  ) as HTMLButtonElement | null;
  const linkInput = document.getElementById(
    "chat-link"
  ) as HTMLInputElement | null;
  const statusEl = document.getElementById("status");
  const chatWrap = document.getElementById("chat-wrap");

  let chatManager: ChatManager | null = null;
  let current = null as null | {
    sessionId: string;
    keyB64Url: string;
    isInitiator: boolean;
  };

  function setStatus(text: string) {
    if (statusEl) statusEl.textContent = text;
  }

  function makeLink(dm: { sessionId: string; keyB64Url: string }): string {
    return `${window.location.origin}/private#pc=${dm.sessionId}.${dm.keyB64Url}`;
  }

  function parseLinkHash(): { sessionId: string; keyB64Url: string } | null {
    const hash = window.location.hash.slice(1);
    if (!hash.startsWith("pc=")) return null;
    const rest = hash.slice(3);
    const [sessionId, keyB64Url] = rest.split(".", 2);
    if (!sessionId || !keyB64Url) return null;
    return { sessionId, keyB64Url };
  }

  async function tryRestoreVault() {
    if (getActiveHandle()) return;
    const last = await getLastVault();
    if (!last) return;
    const status = await checkAccess(last.id);
    if (status === "granted") {
      await restoreSession(last.id);
      window.dispatchEvent(new CustomEvent("workspace-restored"));
    }
  }

  function localStorageKey(sessionId: string): string {
    return `holi.privatechat.${sessionId}.messages.v1`;
  }

  async function loadHistory(sessionId: string) {
    try {
      if (getActiveHandle()) {
        const msgs = await listDmMessages(sessionId);
        for (const m of msgs) {
          (window as any).addChatMessage?.(
            m.text,
            m.from === "me" ? "own" : "peer"
          );
        }
        return;
      }
    } catch {}

    try {
      const raw = window.localStorage.getItem(localStorageKey(sessionId));
      if (!raw) return;
      const data = JSON.parse(raw) as any;
      const msgs = Array.isArray(data?.messages) ? data.messages : [];
      for (const m of msgs) {
        if (m && typeof m.text === "string") {
          (window as any).addChatMessage?.(
            m.text,
            m.from === "me" ? "own" : "peer"
          );
        }
      }
    } catch {}
  }

  async function persistMessage(
    sessionId: string,
    from: "me" | "peer",
    text: string
  ) {
    const msg = { id: crypto.randomUUID(), ts: Date.now(), from, text };
    try {
      if (getActiveHandle()) {
        await saveDmMessage(sessionId, msg as any);
        return;
      }
    } catch {}

    try {
      const key = localStorageKey(sessionId);
      const raw = window.localStorage.getItem(key);
      const data = raw ? JSON.parse(raw) : { version: 1, messages: [] };
      const msgs = Array.isArray(data.messages) ? data.messages : [];
      msgs.push(msg);
      window.localStorage.setItem(
        key,
        JSON.stringify({ version: 1, messages: msgs })
      );
    } catch {}
  }

  async function connect(
    dm: { sessionId: string; keyB64Url: string },
    isInitiator: boolean
  ) {
    if (chatManager) return;
    current = { ...dm, isInitiator };
    if (chatWrap) chatWrap.classList.remove("hidden");

    setStatus(isInitiator ? strings.waitingText : strings.connectingText);

    await tryRestoreVault();
    await loadHistory(dm.sessionId);

    const channel = await connectFriendDmChannel({
      dm,
      isInitiator,
      timeoutMs: 2 * 60_000,
    });

    chatManager = new ChatManager(channel as any, `private:${dm.sessionId}`, {
      sessionKeyBytes: dmKeyBytes(dm.keyB64Url),
      onIncomingFileOffer: async (offer) => {
        const sizeMb = (offer.size / (1024 * 1024)).toFixed(1);
        const ok = confirm(`Receive file "${offer.filename}" (${sizeMb} MB)?`);
        return ok ? "accept" : { decision: "reject", reason: "User rejected" };
      },
    });

    setStatus(strings.connectedText);

    chatManager.on((event: ChatEvent) => {
      if (event.type === "message") {
        const msg = event.message as any;
        const from = msg.senderId === "me" ? "me" : "peer";
        const sender = from === "me" ? "own" : "peer";
        const text = msg.content || "";
        if (!text) return;
        (window as any).addChatMessage?.(text, sender);
        void persistMessage(dm.sessionId, from, text);
      }
    });

    const form = document.getElementById("chat-form");
    const input = document.getElementById(
      "msg-input"
    ) as HTMLInputElement | null;
    form?.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = (input?.value || "").trim();
      if (!text || !chatManager) return;
      chatManager.sendText(text);
      (window as any).addChatMessage?.(text, "own");
      void persistMessage(dm.sessionId, "me", text);
      if (input) input.value = "";
    });
  }

  const fromHash = parseLinkHash();
  if (fromHash) {
    if (linkInput) linkInput.value = makeLink(fromHash);
    if (btnCopy) btnCopy.disabled = false;
    void connect(fromHash, false).catch((e) => {
      console.error(e);
      setStatus(
        strings.failedText + " " + ((e as Error)?.message || String(e))
      );
    });
  } else {
    setStatus(strings.instructionText);
  }

  btnCreate?.addEventListener("click", async () => {
    try {
      const dm = generateDmConfig();
      const url = makeLink(dm);
      if (linkInput) linkInput.value = url;
      if (btnCopy) btnCopy.disabled = false;
      window.location.hash = `pc=${dm.sessionId}.${dm.keyB64Url}`;
      await connect(dm, true);
    } catch (e) {
      console.error(e);
      setStatus("Failed: " + ((e as Error)?.message || String(e)));
    }
  });

  btnCopy?.addEventListener("click", async () => {
    const v = (linkInput?.value || "").trim();
    if (!v) return;
    await navigator.clipboard.writeText(v);
    if (btnCopy) {
      const prev = btnCopy.textContent;
      btnCopy.textContent = strings.copiedText;
      window.setTimeout(() => {
        btnCopy.textContent = prev || strings.copyText;
      }, 1200);
    }
  });
</script>
