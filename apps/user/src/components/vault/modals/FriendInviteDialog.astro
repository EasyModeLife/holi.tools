---

---

<dialog
  id="friend-invite-dialog"
  class="bg-zinc-900 rounded-2xl p-6 backdrop:bg-black/60 max-w-xl w-full"
>
  <div class="space-y-5">
    <div class="flex items-start justify-between gap-4">
      <div>
        <h3 class="text-xl font-bold text-white">Incoming Friend Requests</h3>
        <p class="text-xs text-zinc-500 mt-1">
          People who added you by your Public Key appear here.
        </p>
      </div>
      <button
        type="button"
        id="close-friend-invite-btn"
        class="px-3 py-1 text-zinc-400 hover:text-white transition-colors"
      >
        Close
      </button>
    </div>

    <div class="space-y-2">
      <div id="friend-requests" class="space-y-2">
        <p class="text-xs text-zinc-500 italic">No pending requests.</p>
      </div>
    </div>
  </div>
</dialog>

<script>
  import {
    subscribePubkeySignals,
    getNostrPublicKey,
    publishPubkeySignal,
  } from "../../../lib/p2p/nostr";
  import {
    acceptFriendRequest,
    type IncomingFriendRequest,
  } from "../../../lib/friends/invite";
  import {
    addContactWithNostrPubkey,
    setContactDmByNostrPubkey,
  } from "../../../lib/contacts/store";
  import { getPrimaryIdentity } from "../../../lib/identity/manager";
  import { generateDmConfig } from "../../../lib/friends/dm";
  import { toast } from "../../../lib/ui/toast";

  let reqSub: { close: () => void } | null = null;
  let myPubkey = "";
  const incomingRequests = new Map<
    string,
    IncomingFriendRequest & { status: string }
  >();
  const dialog = document.getElementById(
    "friend-invite-dialog"
  ) as HTMLDialogElement;
  const list = document.getElementById("friend-requests");

  document
    .getElementById("close-friend-invite-btn")
    ?.addEventListener("click", () => dialog.close());

  // Auto-start listening on load
  (async () => {
    try {
      myPubkey = await getNostrPublicKey();
      startListening();
    } catch {
      /* ignore */
    }
  })();

  function startListening() {
    if (!myPubkey) return;
    if (reqSub) reqSub.close();

    // Grace period: Listen for signals from 24 hours ago since we now support persistent events
    const GRACE_PERIOD = 24 * 60 * 60;
    const since = Math.floor(Date.now() / 1000) - GRACE_PERIOD;

    console.log("[FriendInvite] Start Listening as:", myPubkey);

    // 1. Listen for INCOMING REQUESTS
    reqSub = subscribePubkeySignals({
      myPubkey,
      type: "friend_request",
      since,
      onEvent: (evt) => {
        try {
          const data = JSON.parse(evt.content);
          if (!data.requestId || !data.pubkey || !data.dm) return;

          if (incomingRequests.has(data.requestId)) return;

          console.log("[FriendInvite] New Request:", data.requestId);
          incomingRequests.set(data.requestId, { ...data, status: "pending" });

          renderRequests();
          toast.info(`New Friend Request from ${data.name || "someone"}!`);

          if (!dialog.open) {
            const pendingCount = Array.from(incomingRequests.values()).filter(
              (r) => r.status === "pending"
            ).length;
            if (pendingCount > 0) dialog.showModal();
          }
        } catch (e) {
          console.error(e);
        }
      },
    });

    // 2. Listen for ACCEPTED REQUESTS (Closing the loop for the Sender)
    subscribePubkeySignals({
      myPubkey,
      type: "friend_accept",
      since: Math.floor(Date.now() / 1000) - 300, // Only recent accepts (last 5 mins) to avoid spam on reload
      onEvent: async (evt) => {
        try {
          const data = JSON.parse(evt.content);
          // Payload: { requestId, pubkey (Accepter), name, dm }
          // We should check if we already have this contact and if they are trusted.

          console.log("[FriendInvite] Accepted by:", data.name);
          toast.success(`${data.name} accepted your friend request!`);

          // Update their entry to Trusted/Active and save DM info
          await addContactWithNostrPubkey(data.name, data.pubkey);
          await setContactDmByNostrPubkey(data.pubkey, data.dm);

          window.dispatchEvent(new Event("reload-contacts"));
        } catch (e) {
          console.error("[FriendInvite] Error processing accept:", e);
        }
      },
    });
  }

  function renderRequests() {
    if (!list) return;
    const pending = Array.from(incomingRequests.values()).filter(
      (r) => r.status === "pending"
    );

    if (pending.length === 0) {
      list.innerHTML =
        '<p class="text-xs text-zinc-500 italic">No pending requests.</p>';
      return;
    }

    list.innerHTML = "";
    pending.forEach((req) => {
      const row = document.createElement("div");
      row.className =
        "flex items-center justify-between p-3 bg-white/5 rounded-lg border border-white/5";

      const info = document.createElement("div");
      info.innerHTML = `
                <div class="text-sm font-bold text-white">${req.name}</div>
                <div class="text-xs text-zinc-500 font-mono">${req.pubkey.slice(0, 8)}...</div>
            `;

      const actions = document.createElement("div");
      actions.className = "flex gap-2";

      const acceptBtn = document.createElement("button");
      acceptBtn.textContent = "Accept";
      acceptBtn.className =
        "px-3 py-1 bg-green-500/20 text-green-400 rounded hover:bg-green-500/30 text-xs font-medium";
      acceptBtn.onclick = async () => {
        try {
          const myId = await getPrimaryIdentity();
          const dm = generateDmConfig();

          // Use acceptFriendRequest helper if possible, or manual signal
          // Let's use manual signal for Pubkey flow consistency
          const payload = {
            requestId: req.requestId,
            pubkey: myPubkey,
            name: myId?.alias || "Friend",
            dm,
          };

          await publishPubkeySignal({
            targetPubkey: req.pubkey,
            type: "friend_accept", // We'll need to handle this type on sender side if we want confirmation
            content: JSON.stringify(payload),
            persistent: true,
          });

          await addContactWithNostrPubkey(req.name, req.pubkey);
          await setContactDmByNostrPubkey(req.pubkey, dm);

          incomingRequests.set(req.requestId, { ...req, status: "accepted" });
          renderRequests();
          toast.success(`You are now friends with ${req.name}`);
          window.dispatchEvent(new Event("reload-contacts"));
        } catch (e) {
          console.error(e);
          toast.error("Failed to accept");
        }
      };

      const denyBtn = document.createElement("button");
      denyBtn.textContent = "Ignore";
      denyBtn.className =
        "px-3 py-1 bg-white/5 text-zinc-400 rounded hover:bg-white/10 text-xs";
      denyBtn.onclick = () => {
        incomingRequests.set(req.requestId, { ...req, status: "denied" });
        renderRequests();
      };

      actions.appendChild(acceptBtn);
      actions.appendChild(denyBtn);
      row.appendChild(info);
      row.appendChild(actions);
      list.appendChild(row);
    });
  }

  // Export open function
  window.addEventListener("open-friend-requests", () => dialog.showModal());
</script>
