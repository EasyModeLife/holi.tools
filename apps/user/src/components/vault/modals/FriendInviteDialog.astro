---
import { getLangFromUrl, useTranslations } from "../../../i18n/utils";
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

const strings = {
  invites_title: t("friends.invites_title"),
  invites_desc: t("friends.invites_desc"),
  btn_close: t("friends.btn_close"),
  no_invites: t("friends.no_invites"),
  msg_new_invite: t("friends.msg_new_invite"),
  msg_accepted_by: t("friends.msg_accepted_by"),
  btn_accept: t("friends.btn_accept"),
  btn_ignore: t("friends.btn_ignore"),
  msg_now_friends: t("friends.msg_now_friends"),
  error_accept: t("friends.error_accept"),
};
---

<dialog
  id="friend-invite-dialog"
  class="bg-zinc-900 rounded-2xl p-6 backdrop:bg-black/60 max-w-xl w-full"
>
  <div class="space-y-5">
    <div class="flex items-start justify-between gap-4">
      <div>
        <h3 class="text-xl font-bold text-white">{strings.invites_title}</h3>
        <p class="text-xs text-zinc-500 mt-1">
          {strings.invites_desc}
        </p>
      </div>
      <button
        type="button"
        id="close-friend-invite-btn"
        class="px-3 py-1 text-zinc-400 hover:text-white transition-colors"
      >
        {strings.btn_close}
      </button>
    </div>

    <div class="space-y-2">
      <div id="friend-requests" class="space-y-2">
        <p class="text-xs text-zinc-500 italic">{strings.no_invites}</p>
      </div>
    </div>
  </div>
</dialog>

<script define:vars={{ strings }}>
  window.friendInviteStrings = strings;
</script>

<script>
  import {
    subscribePubkeySignals,
    getNostrPublicKey,
    publishPubkeySignal,
  } from "../../../lib/p2p/nostr";
  import {
    acceptFriendRequest,
    type IncomingFriendRequest,
  } from "../../../lib/friends/invite";
  import {
    addContactWithNostrPubkey,
    setContactDmByNostrPubkey,
  } from "../../../lib/contacts/store";
  import { getPrimaryIdentity } from "../../../lib/identity/manager";
  import { generateDmConfig } from "../../../lib/friends/dm";
  import { toast } from "../../../lib/ui/toast";

  const strings = (window as any).friendInviteStrings;
  let reqSub: { close: () => void } | null = null;
  let myPubkey = "";
  const incomingRequests = new Map<
    string,
    IncomingFriendRequest & { status: string }
  >();
  const dialog = document.getElementById(
    "friend-invite-dialog"
  ) as HTMLDialogElement;
  const list = document.getElementById("friend-requests");

  document
    .getElementById("close-friend-invite-btn")
    ?.addEventListener("click", () => dialog.close());

  // Auto-start listening on load
  (async () => {
    try {
      myPubkey = await getNostrPublicKey();
      startListening();
    } catch {
      /* ignore */
    }
  })();

  function startListening() {
    if (!myPubkey) return;
    if (reqSub) reqSub.close();

    // Grace period: Listen for signals from 24 hours ago since we now support persistent events
    const GRACE_PERIOD = 24 * 60 * 60;
    const since = Math.floor(Date.now() / 1000) - GRACE_PERIOD;

    console.log("[FriendInvite] Start Listening as:", myPubkey);

    // 1. Listen for INCOMING REQUESTS
    reqSub = subscribePubkeySignals({
      myPubkey,
      type: "friend_request",
      since,
      onEvent: (evt) => {
        try {
          const data = JSON.parse(evt.content);
          if (!data.requestId || !data.pubkey || !data.dm) return;

          if (incomingRequests.has(data.requestId)) return;

          console.log("[FriendInvite] New Request:", data.requestId);
          incomingRequests.set(data.requestId, { ...data, status: "pending" });

          renderRequests();
          toast.info(
            strings.msg_new_invite.replace("{name}", data.name || "someone")
          );

          if (!dialog.open) {
            const pendingCount = Array.from(incomingRequests.values()).filter(
              (r) => r.status === "pending"
            ).length;
            if (pendingCount > 0) dialog.showModal();
          }
        } catch (e) {
          console.error(e);
        }
      },
    });

    // 2. Listen for ACCEPTED REQUESTS (Closing the loop for the Sender)
    subscribePubkeySignals({
      myPubkey,
      type: "friend_accept",
      since: Math.floor(Date.now() / 1000) - 300, // Only recent accepts (last 5 mins) to avoid spam on reload
      onEvent: async (evt) => {
        try {
          const data = JSON.parse(evt.content);
          // Payload: { requestId, pubkey (Accepter), name, dm }
          // We should check if we already have this contact and if they are trusted.

          console.log("[FriendInvite] Accepted by:", data.name);
          toast.success(strings.msg_accepted_by.replace("{name}", data.name));

          // Update their entry to Trusted/Active and save DM info
          await addContactWithNostrPubkey(data.name, data.pubkey);
          await setContactDmByNostrPubkey(data.pubkey, data.dm);

          window.dispatchEvent(new Event("reload-contacts"));
        } catch (e) {
          console.error("[FriendInvite] Error processing accept:", e);
        }
      },
    });
  }

  function renderRequests() {
    if (!list) return;
    const pending = Array.from(incomingRequests.values()).filter(
      (r) => r.status === "pending"
    );

    if (pending.length === 0) {
      list.innerHTML = `<p class="text-xs text-zinc-500 italic">${strings.no_invites}</p>`;
      return;
    }

    list.innerHTML = "";
    pending.forEach((req) => {
      const row = document.createElement("div");
      row.className =
        "flex items-center justify-between p-3 bg-white/5 rounded-lg border border-white/5";

      const info = document.createElement("div");
      info.innerHTML = `
                <div class="text-sm font-bold text-white">${req.name}</div>
                <div class="text-xs text-zinc-500 font-mono">${req.pubkey.slice(0, 8)}...</div>
            `;

      const actions = document.createElement("div");
      actions.className = "flex gap-2";

      const acceptBtn = document.createElement("button");
      acceptBtn.textContent = strings.btn_accept;
      acceptBtn.className =
        "px-3 py-1 bg-green-500/20 text-green-400 rounded hover:bg-green-500/30 text-xs font-medium";
      acceptBtn.onclick = async () => {
        try {
          const myId = await getPrimaryIdentity();
          const dm = generateDmConfig();

          // Use acceptFriendRequest helper if possible, or manual signal
          // Let's use manual signal for Pubkey flow consistency
          const payload = {
            requestId: req.requestId,
            pubkey: myPubkey,
            name: myId?.alias || "Friend",
            dm,
          };

          await publishPubkeySignal({
            targetPubkey: req.pubkey,
            type: "friend_accept", // We'll need to handle this type on sender side if we want confirmation
            content: JSON.stringify(payload),
            persistent: true,
          });

          await addContactWithNostrPubkey(req.name, req.pubkey);
          await setContactDmByNostrPubkey(req.pubkey, dm);

          incomingRequests.set(req.requestId, { ...req, status: "accepted" });
          renderRequests();
          toast.success(strings.msg_now_friends.replace("{name}", req.name));
          window.dispatchEvent(new Event("reload-contacts"));
        } catch (e) {
          console.error(e);
          toast.error(strings.error_accept);
        }
      };

      const denyBtn = document.createElement("button");
      denyBtn.textContent = strings.btn_ignore;
      denyBtn.className =
        "px-3 py-1 bg-white/5 text-zinc-400 rounded hover:bg-white/10 text-xs";
      denyBtn.onclick = () => {
        incomingRequests.set(req.requestId, { ...req, status: "denied" });
        renderRequests();
      };

      actions.appendChild(acceptBtn);
      actions.appendChild(denyBtn);
      row.appendChild(info);
      row.appendChild(actions);
      list.appendChild(row);
    });
  }

  // Export open function
  window.addEventListener("open-friend-requests", () => dialog.showModal());
</script>
